a.mat <- cbind(rep(1, ncol(predX)), diag(ncol(predX)))
b.vec <- c(1, rep(0, ncol(predX)))
d.vec <- t(Y) %*% predX
out<- solve.QP(Dmat = d.mat, factorized =TRUE, dvec = d.vec, Amat = a.mat, bvec = b.vec, meq = 1)
coefs <- rep(NA, orgcols)
notDel <- c(1:orgcols)[notNA]#[notCor]
coefs[notDel] <- out$solution
return(coefs)
}
regress.func.results<- matrix(nrow = 500, ncol = 9)
for(i in 1:500){
regress.func.results[i,] <- regress.func(Y, results[,,i])
}
error = numeric(9)
for (i in 1:9){
error[i] =sd(regress.func.results[,i])
}
View(error)
plot(error)
View(error)
point.estimate <- regress.func(Y, preds.in.order)
plot(point.estimate)
regress.func(Y, preds.in.order)
results[,,1]
View(preds.in.order)
load("~/GitHub/Project/Het_Experiment.RData")
dem<- ifelse(svdat$pid3l=='Dem', 1, 0)  #line 366-369 of rep code
dem[which(is.na(dem))]<- 0
rep<- ifelse(svdat$pid3l=='Rep', 1, 0)
rep[which(is.na(rep))]<- 0
cons<- ifelse(svdat$ideo3<3, 1, 0) #line 230-231 of rep code
lib<- ifelse(svdat$ideo3==4|svdat$ideo3==5, 1, 0)
lib[which(is.na(lib))]<- 0 #line 370-371 of rep code
cons[which(is.na(cons))]<- 0
## treats
type.mat<- matrix(0, nrow = 1074, ncol=7)
colnames(type.mat)<- sort(unique(as.character(svdat$cond.type)))
for(z in 1:nrow(type.mat)){
type.mat[z,which(colnames(type.mat)==svdat$cond.type[z])]<- 1
}
type.mat.final<- type.mat[,-1]
types<- sort(unique(as.character(svdat$cond.type)))
type.num<- match(svdat$cond.type, types)
number<- c('control', '$20 million', '$50 thousand')
amount.num<- match(svdat$cond.money, number)
request<- c('control', 'requested', 'secured', 'will request')
stage.num<- match(svdat$cond.stage, request)
party<- c('control', 'a Republican', 'a Democrat')
party.num<- match(svdat$cond.party, party)
along<- c('control', 'alone', 'w/ Rep', 'w/ Dem')
along.num<- match(svdat$cond.alongWith, along)
num.mat<- matrix(0, nrow=1074, ncol=3)
colnames(num.mat)<- number
for(z in 1:nrow(num.mat)){
num.mat[z,which(colnames(num.mat)==svdat$cond.money[z])]<- 1
}
num.mat.final<- num.mat[,-1]
stage.mat<- matrix(0, nrow=1074, ncol=4)
colnames(stage.mat)<- request
for(z in 1:nrow(stage.mat)){
stage.mat[z,which(colnames(stage.mat)==svdat$cond.stage[z])]<- 1
}
stage.mat.final<- stage.mat[,-1]
party.mat<- matrix(0, nrow=1074, ncol=3)
colnames(party.mat)<- party
for(z in 1:nrow(party.mat)){
party.mat[z, which(colnames(party.mat)==svdat$cond.party[z])]<- 1
}
party.mat.final<- party.mat[,-1]
along.mat<- matrix(0, nrow=1074, ncol=4)
colnames(along.mat)<- 	along
for(z in 1:nrow(along.mat)){
along.mat[z,which(colnames(along.mat)==svdat$cond.alongWith[z])]<- 1
}
along.mat.final<- along.mat[,-1]
treats<- cbind(type.mat.final, num.mat.final[,1], stage.mat.final[,1:2],party.mat.final[,1],
along.mat.final[,1:2], type.mat.final[,1:5]*num.mat.final[,1], type.mat.final[,1:5]*stage.mat.final[,1],
type.mat.final[,1:5]*stage.mat.final[,2], type.mat.final[,1:5]*party.mat.final[,1], type.mat.final[,1:5]*along.mat.final[,1],
type.mat.final[,1:5]*along.mat.final[,2], num.mat.final[,1]*stage.mat.final[,1], num.mat.final[,1]*stage.mat.final[,2],
num.mat.final[,1]*party.mat.final[,1], num.mat.final[,1]*along.mat.final[,1], num.mat.final[,1]*along.mat.final[,2],
stage.mat.final[,1:2]*party.mat.final[,1], stage.mat.final[,1:2]*along.mat.final[,1],
stage.mat.final[,1:2]*along.mat.final[,2], party.mat.final[,1]*along.mat.final[,1], party.mat.final[,1]*along.mat.final[,2] )
treat<- treats #line 448 of rep code
## X variable
covs<- cbind(dem, rep, lib, cons) #line 373 of rep code
X <- covs #line 432 of repcode
Xfull <- model.matrix(~X*treat)
#Defining the Y variable
Y<- approve_bi<- ifelse(svdat$approval<3, 1, 0) #line 292 of rep code
RMSEforModel = function(x,y, test.indexes = sample(length(y),as.integer(length(y)/10))){
# NOTE: THIS IS NOT DOING CROSS-VALIDATION right now (for most models)
#test.indexes = sample(1074,107)
x.train = x[-test.indexes,]
x.test = x[test.indexes,]
y.train = y[-test.indexes]
y.test = y[test.indexes]
library(glmnet)
##Now predict them
logist<- function(x){
ff<- 1/(1 + exp(-x))
return(ff)
}
##### Take out this Cross-Validation -- just do CV onces for everything to make run faster
# Lasso
fit1<- cv.glmnet(x = x.train, y = y.train, alpha=1, family='binomial', type='mse')
best.lambda = fit1$lambda.min
fit1.predict = predict(fit1, s= best.lambda, newx = x.test)
fit1.logistPred = logist(fit1.predict)
fit1.logistPred.RMSE = sqrt(mean((fit1.logistPred-y.test)^2))
# Elastic Net, Alpha = .5
fit2<- cv.glmnet(y = y.train, x= x.train, alpha=0.5, family='binomial', type='mse')
best.lambda = fit2$lambda.min
fit2.predict = predict(fit2, s= best.lambda, newx = x.test)
fit2.logistPred = logist(fit2.predict)
fit2.logistPred.RMSE = sqrt(mean((fit2.logistPred-y.test)^2))
# Elastic Net, Alpha = .25
fit3<- cv.glmnet(y = y.train, x= x.train, alpha=0.25, family='binomial', type='mse')
best.lambda = fit3$lambda.min
fit3.predict = predict(fit3, s= best.lambda, newx = x.test)
fit3.logistPred = logist(fit3.predict)
fit3.logistPred.RMSE = sqrt(mean((fit3.logistPred-y.test)^2))
# Fit4 not published in paper -- so not doing it
#fit4<- cv.glmnet(y = Y, x= Xfull, alpha=0, family='binomial', type='mse')
## Skipping FindIt since documentation changed (per)
# Bayesian GLM -- Revisit -- probably not working right
library(arm)
fit6<- bayesglm(y.train~x.train-1, family=binomial(link=logit))
fit6.predict = logist(x.test%*%fit6$coefficients)
fit6.logistPred.RMSE = sqrt(mean((fit6.predict-y.test)^2))
# Fit 7 = Boosted Trees is not published ### SKipping
# Fit 8 = BART
library(BayesTree)
fit8<- bart(x.train=x.train, y.train=factor(y.train), x.test=x.test, ndpost=1000, nskip=500, usequants=T)
fit8.pred<- pnorm(apply(fit8$yhat.test, 2, mean))
fit8.rmse = sqrt(mean((fit8.pred-y.test)^2))
# Fit 9  = RandomForest
library(randomForest)
fit9<- randomForest(y = factor(y.train), x = x.train)
X.test.forest = x.test
`colnames<-`(X.test.forest,colnames(x.train))
fit9.pred.raw = predict(fit9,newdata = X.test.forest,type = "prob" )
fit9.pred = fit9.pred.raw[,2]
fit9.rmse = sqrt(mean((fit9.pred-y.test)^2))
# Fit 10 = Skipped in Paper and SLF_round2 code
# Fit 11 = KRLS
library(KRLS)
fit11<- krls(X = x.train[,-1], y = y.train, derivative=F)
fit11.predict = predict(fit11,newdata = x.test[,-1])$fit
fit11.rmse = sqrt(mean((fit11.predict-y.test)^2))
# Fit 12 = SVM-SMO
# library(rJava)
#  .jinit(parameters="-Xmx4g")
# library(RWeka)
#  subset.index = (1:length(y))[-test.indexes]
# fit12 <- SMO(y ~ ., data = data.frame(y=factor(y),x), control = Weka_control(M = TRUE ) , subset = subset.index)
#  fit12.predict =predict(fit12, newdata= data.frame(x[test.indexes,]), type="probability" )[,2]
# fit12.RMSE = sqrt(mean((fit12.predict-y.test)^2))
# Fit 13 = Simple Mean
fit13.predict = mean(y.train)
fit13.RSME= sqrt(mean((fit13.predict-y.test)^2))
models = rbind("Lasso", "Elastic Net (a = .5)","Elastic Net (a = .25)", "Bayesian GLM", "BART", "Random Forest", "KRLS" , "Simple Average")#"SVM_SMO"
Preds.All = cbind(fit1.logistPred,fit2.logistPred,fit3.logistPred,fit6.predict,fit8.pred,fit9.pred,fit11.predict,  fit13.predict)#fit12
#RMSE.all = rbind(fit1.logistPred.RMSE,fit2.logistPred.RMSE,fit3.logistPred.RMSE,fit6.logistPred.RMSE,fit8.rmse,fit9.rmse,fit11.rmse,fit12.RMSE, fit13.RSME)
colnames(Preds.All) = models
#return(data.frame(RMSE.all))
return(Preds.All)
}
load("~/GitHub/Project/Bootstrap Samples.RData")
View(results)
dim(results)
point.estimate <- regress.func(Y, preds.in.order)
regress.func <- function(Y, preds.var){
# need to smartly figure out which columns are not NA
orgcols <- length(preds.var[1,])
notNA <- which(!is.na(preds.var[1,]))
predX <- preds.var[,notNA ]
library(quadprog)
d.mat <- solve(chol(t(predX)%*%predX))
a.mat <- cbind(rep(1, ncol(predX)), diag(ncol(predX)))
b.vec <- c(1, rep(0, ncol(predX)))
d.vec <- t(Y) %*% predX
out<- solve.QP(Dmat = d.mat, factorized =TRUE, dvec = d.vec, Amat = a.mat, bvec = b.vec, meq = 1)
coefs <- rep(NA, orgcols)
notDel <- c(1:orgcols)[notNA]#[notCor]
coefs[notDel] <- out$solution
return(coefs)
}
point.estimate <- regress.func(Y, preds.in.order)
results[,,1]
results[,,1]
x<- as.data.frame(results[,,1])
View(x)
regress.func(Y, preds.in.order)
class(Y)
set.seed(10)
seednum = sample(10000,num.boostraps)
Y.boostrap = numeric(1074,500)
set.seed(10)
seednum = sample(10000,num.boostraps)
Y.boostrap = matrix(nrow = 1074,ncol = 500)
for (i in 1:num.boostraps){
set.seed(seednum[i])
bootstramp.sample.indexes = sample(1074,1074,replace = TRUE)
Y.boostrap[,i] = Y[bootstramp.sample.indexes]
}
View(Y.boostrap)
regress.func.results<- matrix(nrow = 500, ncol = 9)
for(i in 1:500){
regress.func.results[i,] <- regress.func(Y[,i], results[,,i])
}
regress.func.results<- matrix(nrow = 500, ncol = 9)
for(i in 1:500){
regress.func.results[i,] <- regress.func(Y[i,], results[,,i])
}
regress.func.results<- matrix(nrow = 500, ncol = 9)
for(i in 1:500){
regress.func.results[i,] <- regress.func(Y.bootstrap[,i], results[,,i])
}
Y.boostrap
regress.func.results<- matrix(nrow = 500, ncol = 9)
for(i in 1:500){
regress.func.results[i,] <- regress.func(Y.boostrap[,i], results[,,i])
}
View(regress.func.results)
regress.func.results<- matrix(nrow = 500, ncol = 9)
for(i in 1:500){
regress.func.results[i,] <- regress.func(Y.boostrap[,i], results[,,i])
}
regress.func.results
View(regress.func.results)
library(readr)
census_conversions <- read_csv("~/Opioid Public Policy Project/census conversions.txt")
Conversions_2002 <- read_csv("~/Opioid Public Policy Project/Conversions 2002.txt")
Conversions_1998 <- read_csv("~/Opioid Public Policy Project/Conversions 1998.txt")
####
cbp15co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp15co.txt")
cbp14co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp14co.txt")
cbp13co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp13co.txt")
cbp12co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp12co.txt")
cbp11co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp11co.txt")
cbp10co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp10co.txt")
cbp09co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp09co.txt")
cbp08co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp08co.txt")
cbp07co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp07co.txt")
cbp06co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp06co.txt")
cbp05co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp05co.txt")
cbp04co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp04co.txt")
cbp03co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp03co.txt")
cbp02co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp02co.txt")
cbp01co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp01co.txt")
cbp00co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp00co.txt")
cbp99co <- read_csv("~/Opioid Public Policy Project/Census County Plans/cbp99co.txt")
###
subset <- cbp14co[cbp14co$naics %in% c("62142/" , "621420", "6222//", "62221/", "622210", "6232//"), ]
subset<- subset[,1:3 ]
colnames(census_conversions)[1] <- "fipstate"
colnames(census_conversions)[2] <- "fipscty"
colnames(census_conversions)[3] <- "ctyname"
n <- merge(subset, census_conversions ,  by= c("fipstate" , "fipscty" ))
n$Year <- 2014
named <- n
#####
namer<- function(data, conversion, year){
subset <- data[data$naics %in% c("62142/" , "621420", "6222//", "62221/", "622210", "6232//"), ]
subset<- subset[, 1:3]
n <- merge(subset, conversion,  by= c("fipstate" , "fipscty" ))
n$Year <- year
named <<- rbind( named, n)
}
####
namer(cbp13co, census_conversions, 2013)
namer(cbp12co, census_conversions, 2012)
namer(cbp11co, Conversions_2002, 2011)
namer(cbp10co, Conversions_2002, 2010)
namer(cbp09co, Conversions_2002, 2009)
namer(cbp08co, Conversions_2002, 2008)
namer(cbp07co, Conversions_2002, 2007)
namer(cbp06co, Conversions_2002, 2006)
namer(cbp05co, Conversions_2002, 2005)
namer(cbp04co, Conversions_2002, 2004)
namer(cbp03co, Conversions_2002, 2003)
namer(cbp02co, Conversions_2002, 2002)
namer(cbp01co, Conversions_1998, 2001)
namer(cbp00co, Conversions_1998, 2000)
namer(cbp99co, Conversions_1998, 1999)
named$County <- named$ctyname
####
#Substance_Abuse_15 <- cbp15co[cbp15co$NAICS %in% c("62142/" , "621420", "6222//", "62221/", "622210", "6232//"), ]
#Substance_Abuse_15$Year <- 2015
#colnames(census_conversions)[1] <- "FIPSTATE"
#colnames(census_conversions)[2] <- "FIPSCTY"
#colnames(census_conversions)[3] <- "County"
#data_2015<- merge(census_conversions, Substance_Abuse_15, by= c("FIPSTATE" , "FIPSCTY" ))
#####
x<- as.data.frame( table(named$County, named$Year)) #number of facilities
colnames(x)[1] <- "County"
colnames(x)[2] <- "Year"
colnames(x)[3] <- "Number of Facilities"
#### Then run this
MCD <- read_csv("~/Opioid Public Policy Project/Multiple Cause of Death, 1999-2016 (by year).csv")
MCD <- MCD[MCD$Year < 2015,]
merged <- merge( MCD, x, by= c("County", "Year"), all = T) #gives number of deaths. Num of repeated rows in num of deaths
final <- merged
final[is.na(final)] <- 0
a<- lm(final$Deaths ~ final$`Number of Facilities`)
summary(a)
##### Makes differences
final$diffFacilities<-as.vector(unlist(tapply(final$`Number of Facilities`,final$County,FUN=function(x){ return (c(NA,diff(x)))})))
final$diffDeaths<-as.vector(unlist(tapply(final$Deaths,final$County,FUN=function(x){ return (c(NA,diff(x)))})))
final[is.na(final)]<-0
m <- lm(final$diffDeaths ~ final$diffFacilities) # plus population
summary(m)
#### Adds Population parameter
library(stringr)
s<- as.data.frame( str_split_fixed(final$County, ",", 2))
s$V2<- as.character(s$V2)
final$County <- s$V1
final$State <-s$V2
Census_Pop_Data <- read_csv("~/Opioid Public Policy Project/Census Pop Data.csv")
Census_Pop_Data <- Census_Pop_Data[colnames(Census_Pop_Data)[c(6:8)]]
Census_Pop_Data$State <- state.abb[match(Census_Pop_Data$STNAME, state.name)]
colnames(Census_Pop_Data)[2] <- "County"
final$State<- gsub(" ","", final$State)
final.final <- merge(final, Census_Pop_Data, by = c("State", "County"), all.x  = T)
final.final <- final.final[-(1:512),] #gets rid of statewide values
test<- lm( final.final$diffDeaths ~ final.final$diffFacilities + final.final$CENSUS2010POP )
summary(test)
library(tidyr)
data(table1); data(table2); data(table3); data(table4a); data(table4b)
table4a
table4a %>%
gather('1999', '2000', key="year", value="cases")
library(dplyr)
tidy4a <- table4a %>%
gather(`1999`, `2000`, key = "year", value = "cases")
tidy4b <- table4b %>%
gather(`1999`, `2000`, key = "year", value = "population")
tidy4a
tidy4b
left_join(tidy4a, tidy4b)
table2
spread(table2, key = type, value = count)
table3
table3 %>%
separate(rate, into = c("cases", "population"))
table3 %>%
separate(rate, into = c("cases", "population"), sep = "/")
table3 %>%
separate(rate, into = c("cases", "population"), convert = TRUE)
load("~/GitHub/Project/Bootstrap Samples.RData")
x<- results[,,1]
View(x)
View(x)
regress.func(Y, results[,,1])
regress.func <- function(Y, preds.var){
# need to smartly figure out which columns are not NA
orgcols <- length(preds.var[1,])
notNA <- which(!is.na(preds.var[1,]))
predX <- preds.var[,notNA ]
library(quadprog)
d.mat <- solve(chol(t(predX)%*%predX))
a.mat <- cbind(rep(1, ncol(predX)), diag(ncol(predX)))
b.vec <- c(1, rep(0, ncol(predX)))
d.vec <- t(Y) %*% predX
out<- solve.QP(Dmat = d.mat, factorized =TRUE, dvec = d.vec, Amat = a.mat, bvec = b.vec, meq = 1)
coefs <- rep(NA, orgcols)
notDel <- c(1:orgcols)[notNA]#[notCor]
coefs[notDel] <- out$solution
return(coefs)
}
regress.func(Y, results[,,1])
set.seed(10)
seednum = sample(10000,num.boostraps)
Y.boostrap = matrix(nrow = 1074,ncol = 500)
for (i in 1:num.boostraps){
set.seed(seednum[i])
bootstramp.sample.indexes = sample(1074,1074,replace = TRUE)
Y.boostrap[,i] = Y[bootstramp.sample.indexes]
}
View(Y.boostrap)
View(Y.boostrap[,1])
View(Y.boostrap[1,])
regress.func(Y.boostrap[1,], results[,,1])
dim(Y.boostrap)
regress.func(Y.boostrap[,1], results[,,1])
seednum
results
set.seed(10)
seednum = sample(10000,num.boostraps)
seednum
seednum = sample(10000,num.boostraps)
results = array(dim = c(1074,9,num.boostraps))
results
sample(1074,1074,replace = TRUE)
sample(1074,1074,replace = TRUE)
seednum
set.seed(8595)
sample(1074,1074,replace = TRUE)
sample(1074,1074,replace = TRUE)
set.seed(10)
sample(1074,1074,replace = TRUE)
set.seed(10)
sample(1074,1074,replace = TRUE)
Xfull.original
View(Xfull.original)
sample(indexes)
sample(indexes)
indexes = 1:1074 #963 + 111
indexes = sample(indexes)
indexes.first = indexes[1:963]
indexes.matrix.first = matrix(indexes.first,nrow=9)
indexes.last = indexes[964:1074]
indexes.matrix.last = matrix(indexes.last, nrow = 1)
indexes.matrix.first
View(indexes.matrix.first)
View(preds)
set.seed(10)
sample(indexes)
sample(indexes)
num.boostraps = 2
set.seed(10)
seednum = sample(10000,num.boostraps)
results = array(dim = c(1074,9,num.boostraps))
start.time = Sys.time()
debugchecker = numeric()
debugchecker.inner = numeric()
for (i in 1:num.boostraps){
debugchecker = i
set.seed(seednum[i])
bootstramp.sample.indexes = sample(1074,1074,replace = TRUE)
Xfull = Xfull.original[bootstramp.sample.indexes,]
Y = Y.original[bootstramp.sample.indexes]
# With Cross Validation
#should have been a seed here?
indexes = 1:1074 #963 + 111
indexes = sample(indexes)
indexes.first = indexes[1:963]
indexes.matrix.first = matrix(indexes.first,nrow=9)
indexes.last = indexes[964:1074]
indexes.matrix.last = matrix(indexes.last, nrow = 1)
preds = matrix(data = NA, ncol = 9);
for(j in 1:9){
debugchecker.inner=j
temp <-OOSPredicts(Xfull,Y,indexes.matrix.first[j,]) #makes one matrix of data. Rows in random order
preds = rbind(preds,temp)
}
debugchecker.inner=10
last<- OOSPredicts(Xfull,Y,indexes.matrix.last)
preds = rbind(preds,last)
preds.in.order = preds[order(as.numeric(rownames(preds))),]
# Has a  row of all N/As at end that needs to be deleted
preds.in.order = preds.in.order[1:1074,]
results[,,i] = preds.in.order;
}
set.seed(10)
seednum = sample(10000,num.boostraps)
Y.boostrap = matrix(nrow = 1074,ncol = 500)
sample(1074,1074,replace = TRUE)
set.seed()
Y.boostrap[,1]
set.seed(10)
seednum = sample(10000,num.boostraps)
Y.boostrap = matrix(nrow = 1074,ncol = 500)
Y.boostrap[,i]
set.seed(10)
seednum = sample(10000,num.boostraps)
Y.boostrap = matrix(nrow = 1074,ncol = 500)
for (i in 1:num.boostraps){
set.seed(seednum[i])
bootstramp.sample.indexes = sample(1074,1074,replace = TRUE)
Y.boostrap[,i] = Y[bootstramp.sample.indexes]
}
Y.boostrap[,1]
bootstramp.sample.indexes
set.seed(10)
seednum = sample(10000,num.boostraps)
Y.boostrap = matrix(nrow = 1074,ncol = 500)
for (i in 1:num.boostraps){
set.seed(seednum[i])
bootstramp.sample.indexes = sample(1074,1074,replace = TRUE)
Y.boostrap = Y[bootstramp.sample.indexes]
}
regress.func(Y.boostrap[,1], results[,,1])
regress.func(Y.boostrap, results[,,1])
dim(Y.boostrap)
set.seed(10)
seednum = sample(10000,num.boostraps)
Y.boostrap = matrix(nrow = 1074,ncol = 500)
for (i in 1:num.boostraps){
set.seed(seednum[i])
bootstramp.sample.indexes = sample(1074,1074,replace = TRUE)
Y.boostrap = Y[bootstramp.sample.indexes]
}
dim(Y.boostrap)
bootstramp.sample.indexes = sample(1074,1074,replace = TRUE)
sample(1074,1074,replace = TRUE)
Y = Y[bootstramp.sample.indexes]
Y
regress.func(Y, results[,,1])
dim(Y)
Y = Y[bootstramp.sample.indexes]
x<- results[,,1]
Y = Y[bootstramp.sample.indexes]
x<- results[,,1]
Y = Y[bootstramp.sample.indexes]
dim(Y)
Y[bootstramp.sample.indexes]
load("~/GitHub/Project/Bootstrap Samples.RData")
bootstramp.sample.indexes = sample(1074,1074,replace = TRUE)
Xfull = Xfull.original[bootstramp.sample.indexes,]
Y = Y.original[bootstramp.sample.indexes]
results[,,1]
