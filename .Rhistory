<<<<<<< HEAD
=======
<<<<<<< HEAD
n=5
matrix1 <- replicate(m, rnorm(n)) # create matrix
matdf <- matdf1 <- matdf2 <- data.frame(matrix1) # transform into data frame
matdf
for (i in 1:m) {
for (j in 1:n) {
matdf1[i,j] <- matdf1[i,j] + 1.87*cos(.25)*pi # addition
}
}
matdf1
matdf2 <- matdf2 + 1.87*cos(.25)*pi
matdf2
microbenchmark(
"loop" = for (i in 1:m) {
for (j in 1:n) {
matdf[i,j] <- matdf[i,j] + 1.87*cos(.25)*pi
}
},
"vectorized" = matdf <- matdf + 1.87*cos(.25)*pi
)
## rowSums / colSums
mat1 <- matrix(abs(rnorm(2500))+pi, ncol=50)
head(mat1)[,1:5]
apply(mat1, 1, function(x) sum(x))
rowSums(mat1)
microbenchmark(apply(mat1, 1, function(x) sum(x)),
rowSums(mat1))
## rowMeans/colMeans
apply(mat1, 2, function(x) mean(x))
colMeans(mat1)
microbenchmark(apply(mat1, 2, function(x) mean(x)),
colMeans(mat1))
## Even when working with matrices, think about the actual
## calculations you perform
mat2 <- matrix(sample(1:7, 90000, replace=T), ncol=300)
mat3 <- matrix(sample(2:6, 90000, replace=T), ncol=300)
ys <- sample(3:5, 300, replace=T)
all.equal(mat2 %*% mat3 %*% ys , mat2 %*% (mat3 %*% ys))
microbenchmark(mat2 %*% mat3 %*% ys,
mat2 %*% (mat3 %*% ys))
## Crossproducts
mat4 <- matrix(1:4, ncol=2)
mat5 <- matrix(5:8, ncol=2)
microbenchmark(t(mat4)%*%mat5,
crossprod(mat4, mat5))
## Paste/collapse and copies
random_states <- function() {
paste(sample(state.name,10,replace =TRUE),collapse ="")
}
states10 <- replicate(10, random_states())
states10
states100 <- replicate(100, random_states())
collapse <- function(states) {
out <- ""
for (x in states) {
out <- paste0(out, x) # same as paste(..., sep="", collapse)
}
out
}
microbenchmark(
"loop10" = collapse(states10),
"vec10" = paste(states10, collapse =""),
"loop100" = collapse(states100),
"vec100" = paste(states100, collapse ="")
)
## Here, we are not only getting around using the loop, but also
## avoiding copies. Whenever you append(), cbind(), rbind(), or
## paste() to create a bigger object, R must first allocate space
## for the new object and then copy the old object to its new home.
## If you're repeating this many times, like in a for loop, this
## can be quite computationally expensive.
## Parallelization
## Parallelization uses multiple cores to work simultaneously on different
## parts of a problem. It doesn't reduce the computing time, but it saves
## your time because you're using more of your computer's resources.
install.packages("parallel")
library(parallel)
cores <- detectCores()
cores
pause <- function(i) {
function(x) Sys.sleep(i)
}
## On a Mac:
microbenchmark(
lapply(1:4, pause(0.25)),
mclapply(1:4, pause(0.25), mc.cores = cores),
times=10
)
## On a Windows machine:
cluster <- makePSOCKcluster(cores)
microbenchmark(
parLapply(cluster, 1:4, pause(0.25)),
lapply(1:4, pause(0.25)),
times=10
)
## More generally with apply/plyr family
library(plyr)
bigmat <- matrix(rnorm(90000), ncol=300)
dim(bigmat)
## Mac:
install.packages("doMC")
library(doMC)
registerDoMC(3) # register number of cores
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
times=20
)
## But of course we now know that this should really be colSums
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
"vectorized" = colSums(bigmat),
times=20
)
## Windows:
install.packages("foreach")
library(foreach)
install.packages("doSNOW")
library(doSNOW)
registerDoSNOW(makeCluster(2, type = "SOCK")) # set to two cores
getDoParWorkers() # check number of cores
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
times=20
)
## But of course we now know that this should really be colSums
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
"vectorized" = colSums(bigmat),
times=20
)
install.packages("microbenchmark")
install.packages("doSNOW")
install.packages("foreach")
install.packages("doSNOW")
install.packages("foreach")
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
"vectorized" = colSums(bigmat),
times=20
)
warnings()
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
"vectorized" = colSums(bigmat),
times=20
)
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"vectorized" = colSums(bigmat),
times=20
)
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum),
"vectorized" = colSums(bigmat),
times=20
)
install.packages("foreach")
library(foreach)
install.packages("foreach")
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum),
"vectorized" = colSums(bigmat),
times=20
)
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
"vectorized" = colSums(bigmat),
times=20
)
library(foreach)
library(doSNOW)
registerDoSNOW(makeCluster(2, type = "SOCK")) # set to two cores
getDoParWorkers() # check number of cores
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
times=20
)
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
"vectorized" = colSums(bigmat),
times=20
)
warnings()
library(microbenchmark)
microbenchmark(sqrt(x),
x^0.5,
times=1000)
head(mtcars)
microbenchmark(
"[32, 11]" = mtcars[32,11],
"$carb[32]"	= mtcars$carb[32],
"[[c(11, 32)]]" = mtcars[[c(11,32)]],
"[[11]][32]" = mtcars[[11]][32],
".subset2" = .subset2(mtcars,11)[32])
library(profvis)
m=5
n=5
matrix1 <- replicate(m, rnorm(n)) # create matrix
matdf <- matdf1 <- matdf2 <- data.frame(matrix1) # transform into data frame
matdf
for (i in 1:m) {
for (j in 1:n) {
matdf1[i,j] <- matdf1[i,j] + 1.87*cos(.25)*pi # addition
}
}
matdf1
matdf2 <- matdf2 + 1.87*cos(.25)*pi
matdf2
microbenchmark(
"loop" = for (i in 1:m) {
for (j in 1:n) {
matdf[i,j] <- matdf[i,j] + 1.87*cos(.25)*pi
}
},
"vectorized" = matdf <- matdf + 1.87*cos(.25)*pi
)
mat1 <- matrix(abs(rnorm(2500))+pi, ncol=50)
head(mat1)[,1:5]
apply(mat1, 1, function(x) sum(x))
rowSums(mat1)
microbenchmark(apply(mat1, 1, function(x) sum(x)),
rowSums(mat1))
apply(mat1, 2, function(x) mean(x))
colMeans(mat1)
microbenchmark(apply(mat1, 2, function(x) mean(x)),
colMeans(mat1))
mat2 <- matrix(sample(1:7, 90000, replace=T), ncol=300)
mat3 <- matrix(sample(2:6, 90000, replace=T), ncol=300)
ys <- sample(3:5, 300, replace=T)
all.equal(mat2 %*% mat3 %*% ys , mat2 %*% (mat3 %*% ys))
microbenchmark(mat2 %*% mat3 %*% ys,
mat2 %*% (mat3 %*% ys))
mat4 <- matrix(1:4, ncol=2)
mat5 <- matrix(5:8, ncol=2)
microbenchmark(t(mat4)%*%mat5,
crossprod(mat4, mat5))
random_states <- function() {
paste(sample(state.name,10,replace =TRUE),collapse ="")
}
states10 <- replicate(10, random_states())
states10
states100 <- replicate(100, random_states())
collapse <- function(states) {
out <- ""
for (x in states) {
out <- paste0(out, x) # same as paste(..., sep="", collapse)
}
out
}
microbenchmark(
"loop10" = collapse(states10),
"vec10" = paste(states10, collapse =""),
"loop100" = collapse(states100),
"vec100" = paste(states100, collapse ="")
)
library(parallel)
cores <- detectCores()
cores
pause <- function(i) {
function(x) Sys.sleep(i)
}
cluster <- makePSOCKcluster(cores)
microbenchmark(
parLapply(cluster, 1:4, pause(0.25)),
lapply(1:4, pause(0.25)),
times=10
)
library(plyr)
bigmat <- matrix(rnorm(90000), ncol=300)
dim(bigmat)
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
"vectorized" = colSums(bigmat),
times=20
)
library(foreach)
library(foreach)
library(doSNOW)
registerDoSNOW(makeCluster(2, type = "SOCK")) # set to two cores
getDoParWorkers() # check number of cores
microbenchmark(
"solo" = aaply(bigmat, 2, sum),
"parallel" = aaply(bigmat, 2, sum, .parallel=T),
times=20
)
setwd("~/GitHub/Project")
load("~/GitHub/Project/Het_Experiment.RData")
#What to do, define every variable in this file
######################################################
###### From SLF_round 2 -- Comments by Jon ###########
######################################################
## See table 2 on pg 422 of Reference Paper for full list of methods
################## Setup ###############
## Packages you will need to install (uncomment and run this section once):
## You can uncomment all lines at once by highlighting the lines, then ctrl+shift+c
# install.packages(glmnet)
# install.packages(FindIt)
# install.packages(arm)
# install.packages(GAMBoost)
# install.packages(mboost)
# install.packages("KRLS")
# install.packages("rJava")
# install.packages("RWeka")
############# different def of covs on line 863 of rep code. Investigate this
# Set WD as needed:
setwd("C:/Users/jgros/documents/GitHub/Project/")
load("Het_Experiment.Rdata")
dem<- ifelse(svdat$pid3l=='Dem', 1, 0)  #line 366-369 of rep code
=======
create.plot4<- function(var1, pos.values_var1, labels_1, var2, pos.values, vert.label, xlim=c(-0.4, 0.4), left = 6, right= 6, mult, multiplier){
num.facts<- len(pos.values)
num.right<- len(pos.values_var1)
fill<- matrix(0, nrow=num.right, ncol=num.facts)
tt<- 1:nrow(treat.mat)
av.effect<- function(subset){
out<- mean(final.eff[subset])
print(out)
>>>>>>> 3cf8894b74faea8fbfc8d733624d28dbf3c22762
}
print("\nPredicting SVM-SMO")
pred.vals[,12]<- predict(fit12, newdata= data.frame(Xtfull), type="probability" )[,2]
print("\nSaving Models")
fitstxt <- grep("fit", ls(), value=T)
reords<- paste('fit', 1:12, sep='')
fitstxt<- reords[which(reords %in% fitstxt)]
# Create a list with each model as the ith element so that we can return it
# easily as output
fits <- list()
for( i in 1:length(fitstxt)){
fits[[i]] <- eval(parse(text=fitstxt[i]))
}
return(list(pred.vals, fits))
}
supLearnFit <- function(X, treats, Y, nfold = 10, speed=T){
# first straighten out data:
if(class(X)=='matrix' | class(X)=='data.frame' & any(is.na(X)) ==F){
toInclude <- complete.cases(cbind(X,treats,Y))
X <- X[toInclude,]}
if(class(X)!= 'matrix' & class(X) != 'data.frame' & any(is.na(X))==F){
toInclude <- complete.cases(cbind(X,treats,Y))
X<- X[toinclude]}
if(any(is.na(X))==T){
toInclude<- complete.cases(cbind(treats, Y))
}
Y <- Y[toInclude]
if(class(treats)=='matrix'|class(treats)=='data.frame'){
treats <- treats[toInclude,]
}
if(class(treats)!= 'matrix' & class(treats)!= 'data.frame'){
treats<- treats[toInclude]}
#Xfull <- model.matrix(~X*treats)
Xfull<- X
##this is the quadratic programming solution to the weights on the forecasters
regress.func <- function(Y, preds.var){
# need to smartly figure out which columns are not NA
orgcols <- length(preds.var[1,])
notNA <- which(!is.na(preds.var[1,]))
predX <- preds.var[,notNA ]
library(quadprog)
d.mat <- solve(chol(t(predX)%*%predX))
a.mat <- cbind(rep(1, ncol(predX)), diag(ncol(predX)))
b.vec <- c(1, rep(0, ncol(predX)))
d.vec <- t(Y) %*% predX
out<- solve.QP(Dmat = d.mat, factorized =TRUE, dvec = d.vec, Amat = a.mat, bvec = b.vec, meq = 1)
coefs <- rep(NA, orgcols)
notDel <- c(1:orgcols)[notNA]#[notCor]
coefs[notDel] <- out$solution
return(coefs)
}
## 10fcv
fold <- sample(nfold, nrow(X), replace = T)
preds.var <- matrix(NA, nrow=nrow(X),ncol=12)
wrapresults <- list()
# This will store each CV pred fold
for (z in sort(unique(fold))) {
print(cat(paste('Fold', z, sep = ' ' ), '\n'))
X.train<- Xfull[fold != z,]
X.test <- Xfull[fold == z,]
Y.train <- Y[fold != z]
Y.test <- Y[fold == z]
if(is.null(ncol(treats))==F){
treats.train <- treats[fold != z,]
treats.test <- treats[fold == z,]
}
if(is.null(ncol(treats))==T){
treats.train <- treats[fold != z]
treats.test <- treats[fold == z]}
#		debugonce(wrap.func)
wrapresults[[z]] <- wrap.func(X.train, Y.train,
treats.train, X.test, Y.test, treats.test, speed=speed)[[1]]
preds.var[fold == z,] <- wrapresults[[z]]
}
# Now run the function:
store <- regress.func(Y, preds.var)
store
names(store) <- c('lasso', 'e_net_0.75', 'e_net_0.5', 'e_net_0.25', 'FindIt',
'BayesGLM', 'GLMBoost', 'BART', 'RandomForest', 'glm', 'KRLS', 'SVM-SMO')
print(round(store, 4))
return( list(store, preds.var) )
}
len<- length
predict.weight<- function(weights, models, new.treats, new.conts, X.train, Y){
weights_use<- na.omit(weights[[1]])
use<- 1:len(weights_use)
preds.treat<-preds.cont<- matrix(NA, nrow = nrow(new.treats), ncol=len(use))
a<- 0
for(z in use){
if(class(models[[2]][[z]])[1] =='cv.glmnet'){
a<- a + 1
preds.treat[,a]<-logist(predict(models[[2]][[z]]$glmnet.fit, newx = new.treats, s= models[[2]][[z]]$lambda.min))
preds.cont[,a]<-logist(predict(models[[2]][[z]]$glmnet.fit, newx = new.conts, s= models[[2]][[z]]$lambda.min))
print('glmnet')
}
if(class(models[[2]][[z]])[1]=='FindIt'){
a <- a + 1
preds.treat[,a]<- (new.treats%*%models[[2]][[z]]$coefs)/2 + 0.5
preds.cont[,a]<- (new.conts%*%models[[2]][[z]]$coefs)/2 + 0.5
print('FindIt')
}
if(class(models[[2]][[z]])[1]=='bayesglm'){
a <- a + 1
preds.treat[,a]<- logist(new.treats%*%models[[2]][[z]]$coef)
preds.cont[,a]<- logist(new.conts%*%models[[2]][[z]]$coef)
print('GLM')
}
if(class(models[[2]][[z]])[1]=='krls'){
a<- a + 1
##we need to do this by the 10k
if(nrow(new.treats)<10000){
preds.treat[,a]<- predict(models[[2]][[z]], newdata = new.treats[,-1])$fit
preds.cont[,a]<- predict(models[[2]][[z]], newdata= new.conts[,-1])$fit
}
if(nrow(new.treats)>10000){
art<- nrow(new.treats)/10000
rems<- nrow(new.treats)%%10000
seqs<- seq(1, nrow(new.treats) - rems, by=10000)
seqs<- c(seqs, nrow(new.treats) - rems, nrow(new.treats[,-1]))
for(aa in 1:(len(seqs)-1)){
preds.treat[seqs[aa]:seqs[aa+1],a]<- predict(models[[2]][[z]], newdata = new.treats[seqs[aa]:seqs[aa+1], -1])$fit
preds.cont[seqs[aa]:seqs[aa+1],a]<- predict(models[[2]][[z]], newdata= new.conts[seqs[aa]:seqs[aa+1], -1])$fit
}
}
print('KRLS')
}
if(class(models[[2]][[z]])[1]=='SMO'){
a<- a + 1
preds.treat[,a]<- predict(models[[2]][[z]], newdata=data.frame(new.treats), type="probability" )[,2]
preds.cont[,a]<- predict(models[[2]][[z]], newdata = data.frame(new.conts), type="probability" )[,2]
print('SMO')
}
if(class(models[[2]][[z]])[1]=='glmboost'){
a<- a + 1
preds.treat[,a]<- 1 -  (attr(coef(models[[2]][[z]]), 'offset') + coef(models[[2]][[z]])%*%t(new.treats[,c(1,sort(unique(selected(models[[2]][[z]]))))]))
preds.cont[,a]<- 1 - (attr(coef(models[[2]][[z]]), 'offset') + coef(models[[2]][[z]])%*%t(new.conts[,c(1,sort(unique(selected(models[[2]][[z]]))))]))
print('GLMBoost')
}
if(class(models[[2]][[z]])[1]=='bart'){
a<- a + 1
pred.bart<- bart(x.train = X.train, y.train = Y, x.test = rbind(new.treats, new.conts), ndpost=1000, nskip=500, usequants=T)
t.nums<- 1:nrow(new.treats)
c.nums<- (nrow(new.treats) + 1):(nrow(new.treats)  + nrow(new.conts))
preds.treat[,a]<- pnorm(apply(pred.bart$yhat.test[,t.nums], 2, mean))
preds.cont[,a]<- pnorm(apply(pred.bart$yhat.test[,c.nums], 2, mean))
print("BART")
}
if(class(models[[2]][[z]])[1]=='randomForest'){
a<- a + 1
preds.treat[,a]<- predict(models[[2]][[z]], newdata = new.treats, type='prob')[,2]
preds.cont[,a]<- predict(models[[2]][[z]], newdata = new.conts, type='prob')[,2]
print('randomForest')
}
}
output<- list(preds.treat, preds.cont, weights_use)
names(output)<- c('Treated', 'Control', 'Weights')
return(output)
}
library(Rcpp)
library(devtools)
library(roxygen2)
setwd("~/Dropbox/Classes/R Programming/R Scripts")
dir()
setwd("~/Dropbox/Classes/R Programming/R Scripts")
Rcpp.package.skeleton("easyEBMA2", cpp_files=c("./easyEM.cpp"))
current.code <- as.package("easyEBMA2")
load_all(current.code)
document(current.code)
help(weightedNormals)
getwd()
setwd("/Users/emilygarner/Documents/School/Second Sem/R")
dir()
Rcpp.package.skeleton("easyEBMA2", cpp_files=c("./easyEM.cpp"))
current.code <- as.package("easyEBMA2")
load_all(current.code)
document(current.code)
help(weightedNormals)
struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;
cppFunction('int add(int x, int y, int z) {
int sum = x + y + z;
return sum;
}')
add(2, 1, 3)
add(2.1, 1.2, 3.3)
cppFunction('double add(double x, double y, double z) {
int sum = x + y + z;
return sum;
}')
add(2, 1, 3)
add(2.3, 1.5, 3.5)
cppFunction('int add(int x, int y, int z) {
int sum = x + y + z;
return sum;
}')
add(2, 1, 3)
add(2.1, 1.2, 3.3)
cppFunction('double add(double x, double y, double z) {
double sum = x + y + z;
return sum;
}')
add(2, 1, 3)
add(2.3, 1.5, 3.5)
cppFunction('double stupidSumCpp(NumericVector x) {
int n = x.size();
double total=0;
for(int i=0; i<n; ++i) {
total += x[i];
}
<<<<<<< HEAD
return total;
}')
cppFunction('double stupidSumCppIt(NumericVector x) {
double total=0;
NumericVector::iterator it;
for(it = x.begin(); it != x.end(); ++it) {
total += *it;
}
return total;
}')
cppFunction('double stupidSumCppIt(NumericVector x) {
double total=0;
NumericVector::iterator it;
for(it = x.begin(); it != x.end(); ++it) {
total += *it;
}
return total;
}')
microbenchmark(stupidSumCpp(runif(1000)), times=10000)
library(microbenchmark)
microbenchmark(stupidSumCpp(runif(1000)), times=10000)
microbenchmark(stupidSumCpp(runif(1000)), times=10000)
microbenchmark(stupidSumCppIt(runif(1000)), times=10000)
install.packages("glmnet")
install.packages("arm")
install.packages("GAMBoost")
install.packages("mboost")
install.packages("KRLS")
install.packages("rJava")
install.packages("RWeka")
=======
par(mfrow=c(1,1))
create.plot4(right_var, 1, name3, left_var, 1:26, new_label,xlim =c(-0.25, 0.25), left =10, right = 8, multiplier= rep(point_size, 2), mult = 50)
dev.copy(device=pdf, file='~/Dropbox/creditClaimingProjects/het/NewBlame1.pdf', height = 8, width = 6)
dev.off()
create.plot4(right_var, 2, name3[2], left_var, 1:26, new_label,xlim =c(-0.25, 0.25), left =10, right = 8, multiplier= rep(point_size, 2), mult = 50)
dev.copy(device=pdf, file='~/Dropbox/creditClaimingProjects/het/NewBlame2.pdf', height = 8, width = 6)
dev.off()
Xfull <- model.matrix(~X*treat)
X <- covs #line 432 of repcode
covs<- cbind(dem, rep, lib, cons) #line 373 of rep code
Xfull <- model.matrix(~X*treat)
X <- covs #line 432 of repcode
covs<- cbind(dem, rep, lib, cons) #line 373 of rep code
dem<- ifelse(svdat$pid3l=='Dem', 1, 0) Line #line 366-369 of rep code
>>>>>>> bf7998bd49f5b12b9a6b3cbe6c67a57a4f70aeca
dem[which(is.na(dem))]<- 0
rep<- ifelse(svdat$pid3l=='Rep', 1, 0)
rep[which(is.na(rep))]<- 0
cons<- ifelse(svdat$ideo3<3, 1, 0) #line 230-231 of rep code
lib<- ifelse(svdat$ideo3==4|svdat$ideo3==5, 1, 0)
lib[which(is.na(lib))]<- 0 #line 370-371 of rep code
cons[which(is.na(cons))]<- 0
<<<<<<< HEAD
############ Defining treats
type.mat<- matrix(0, nrow = 1074, ncol=7)
colnames(type.mat)<- sort(unique(as.character(svdat$cond.type)))
for(z in 1:nrow(type.mat)){
type.mat[z,which(colnames(type.mat)==svdat$cond.type[z])]<- 1
}
type.mat.final<- type.mat[,-1]
types<- sort(unique(as.character(svdat$cond.type)))
type.num<- match(svdat$cond.type, types)
number<- c('control', '$20 million', '$50 thousand')
amount.num<- match(svdat$cond.money, number)
request<- c('control', 'requested', 'secured', 'will request')
stage.num<- match(svdat$cond.stage, request)
party<- c('control', 'a Republican', 'a Democrat')
party.num<- match(svdat$cond.party, party)
along<- c('control', 'alone', 'w/ Rep', 'w/ Dem')
along.num<- match(svdat$cond.alongWith, along)
num.mat<- matrix(0, nrow=1074, ncol=3)
colnames(num.mat)<- number
for(z in 1:nrow(num.mat)){
num.mat[z,which(colnames(num.mat)==svdat$cond.money[z])]<- 1
}
num.mat.final<- num.mat[,-1]
stage.mat<- matrix(0, nrow=1074, ncol=4)
colnames(stage.mat)<- request
for(z in 1:nrow(stage.mat)){
stage.mat[z,which(colnames(stage.mat)==svdat$cond.stage[z])]<- 1
}
stage.mat.final<- stage.mat[,-1]
party.mat<- matrix(0, nrow=1074, ncol=3)
colnames(party.mat)<- party
for(z in 1:nrow(party.mat)){
party.mat[z, which(colnames(party.mat)==svdat$cond.party[z])]<- 1
}
party.mat.final<- party.mat[,-1]
along.mat<- matrix(0, nrow=1074, ncol=4)
colnames(along.mat)<- 	along
for(z in 1:nrow(along.mat)){
along.mat[z,which(colnames(along.mat)==svdat$cond.alongWith[z])]<- 1
}
along.mat.final<- along.mat[,-1]
=======
treat<- treats #line 448 of rep code
>>>>>>> bf7998bd49f5b12b9a6b3cbe6c67a57a4f70aeca
treats<- cbind(type.mat.final, num.mat.final[,1], stage.mat.final[,1:2],party.mat.final[,1],
along.mat.final[,1:2], type.mat.final[,1:5]*num.mat.final[,1], type.mat.final[,1:5]*stage.mat.final[,1],
type.mat.final[,1:5]*stage.mat.final[,2], type.mat.final[,1:5]*party.mat.final[,1], type.mat.final[,1:5]*along.mat.final[,1],
type.mat.final[,1:5]*along.mat.final[,2], num.mat.final[,1]*stage.mat.final[,1], num.mat.final[,1]*stage.mat.final[,2],
num.mat.final[,1]*party.mat.final[,1], num.mat.final[,1]*along.mat.final[,1], num.mat.final[,1]*along.mat.final[,2],
stage.mat.final[,1:2]*party.mat.final[,1], stage.mat.final[,1:2]*along.mat.final[,1],
stage.mat.final[,1:2]*along.mat.final[,2], party.mat.final[,1]*along.mat.final[,1], party.mat.final[,1]*along.mat.final[,2] )
<<<<<<< HEAD
treat<- treats #line 448 of rep code
### Defining the X variable
covs<- cbind(dem, rep, lib, cons) #line 373 of rep code
X <- covs #line 432 of repcode
Xfull <- model.matrix(~X*treat)
## line 391 of rep code
#Defining the Y variable
#line 432 of rep code
Y<- approve_bi<- ifelse(svdat$approval<3, 1, 0) #line 292 of rep code
covstest_1 <- covs[c(1:107),]
covstest_2<- covs[c(108:215),]
covstest_3<- covs[c(216:323),]
covstest_4<- covs[c(324:431),]
covstest_5<- covs[c(432:539),]
covstest_6<- covs[c(540:647),]
covstest_7<- covs[c(648:755),]
covstest_8<- covs[c(756:863),]
covstest_9<- covs[c(864:971),]
covstest_10<- covs[c(972:1074),]
covsfull_1 <- covs[-covstest_1,]
covsfull_2 <- covs[-covstest_2,]
covsfull_3 <- covs[-covstest_3,]
covsfull_4 <- covs[-covstest_4,]
covsfull_5 <- covs[-covstest_5,]
covsfull_6 <- covs[-covstest_6,]
covsfull_7 <- covs[-covstest_7,]
covsfull_8 <- covs[-covstest_8,]
covsfull_9 <- covs[-covstest_9,]
covsfull_10 <- covs[-covstest_10,]
####def of 1/10 for treat
treattest_1 <- treat[c(1:107),]
treattest_2<- treat[c(108:215),]
treattest_3<- treat[c(216:323),]
treattest_4<-treat[c(324:431),]
treattest_5<- treat[c(432:539),]
treattest_6<- treat[c(540:647),]
treattest_7<- treat[c(648:755),]
treattest_8<- treat[c(756:863),]
treattest_9<- treat[c(864:971),]
treattest_10<- treat[c(972:1074),]
treatfull_1 <-treat[-treattest_1,]
treatfull_2 <- treat[-treattest_2,]
treatfull_3 <- treat[-treattest_3,]
treatfull_4 <- treat[-treattest_4,]
treatfull_5 <- treat[-treattest_5,]
treatfull_6 <- treat[-treattest_6,]
treatfull_7 <- treat[-treattest_7,]
treatfull_8 <- treat[-treattest_8,]
treatfull_9 <- treat[-treattest_9,]
treatfull_10 <- treat[-treattest_10,]
Yfull_1<- ifelse(svdat[-c(1:107),]$approval<3, 1, 0)
Yfull_2<- ifelse(svdat[-c(108:215),]$approval<3, 1, 0)
Yfull_3<- ifelse(svdat[-c(216:323),]$approval<3, 1, 0)
Yfull_4<- ifelse(svdat[-c(324:431),]$approval<3, 1, 0)
Yfull_5<- ifelse(svdat[-c(432:539),]$approval<3, 1, 0)
Yfull_6<- ifelse(svdat[-c(540:647),]$approval<3, 1, 0)
Yfull_7<- ifelse(svdat[-c(648:755),]$approval<3, 1, 0)
Yfull_8<- ifelse(svdat[-c(756:863),]$approval<3, 1, 0)
Yfull_9<- ifelse(svdat[-c(864:971),]$approval<3, 1, 0)
Yfull_10<- ifelse(svdat[-c(972:1074),]$approval<3, 1, 0)
Xfull <- model.matrix(~covs*treat)
Xfull_1 <-model.matrix(~covsfull_1*treatfull_1)
xtest<- model.matrix(~covstest_1*treattest_1)
fit8<- bart(x.train=Xfull, y.train=factor(Y), x.test=Xtfull, ndpost=1000, nskip=500, usequants=T)
library(BayesTree)
fit8<- bart(x.train=Xfull, y.train=factor(Y), x.test=Xtfull, ndpost=1000, nskip=500, usequants=T)
Xfull<-Xtfull <- model.matrix(~covs*treat)
fit8<- bart(x.train=Xfull, y.train=factor(Y), x.test=Xtfull, ndpost=1000, nskip=500, usequants=T)
nrow(Yfull_1)
Yfull_1<- ifelse(svdat[-c(1:107),]$approval<3, 1, 0)
nrow(Yfull_1)
covstest_1 <- covs[c(0:107),]
treattest_1 <- treat[c(0:107),]
Yfull_1<- ifelse(svdat[-c(0:107),]$approval<3, 1, 0)
covstest_1 <- covs[c(0:107),]
covstest_2<- covs[c(108:215),]
covstest_3<- covs[c(216:323),]
covstest_4<- covs[c(324:431),]
covstest_5<- covs[c(432:539),]
covstest_6<- covs[c(540:647),]
covstest_7<- covs[c(648:755),]
covstest_8<- covs[c(756:863),]
covstest_9<- covs[c(864:971),]
covstest_10<- covs[c(972:1074),]
covsfull_1 <- covs[-covstest_1,]
covsfull_2 <- covs[-covstest_2,]
covsfull_3 <- covs[-covstest_3,]
covsfull_4 <- covs[-covstest_4,]
covsfull_5 <- covs[-covstest_5,]
covsfull_6 <- covs[-covstest_6,]
covsfull_7 <- covs[-covstest_7,]
covsfull_8 <- covs[-covstest_8,]
covsfull_9 <- covs[-covstest_9,]
covsfull_10 <- covs[-covstest_10,]
treattest_1 <- treat[c(0:107),]
treattest_2<- treat[c(108:215),]
treattest_3<- treat[c(216:323),]
treattest_4<-treat[c(324:431),]
treattest_5<- treat[c(432:539),]
treattest_6<- treat[c(540:647),]
treattest_7<- treat[c(648:755),]
treattest_8<- treat[c(756:863),]
treattest_9<- treat[c(864:971),]
treattest_10<- treat[c(972:1074),]
treatfull_1 <-treat[-treattest_1,]
treatfull_2 <- treat[-treattest_2,]
treatfull_3 <- treat[-treattest_3,]
treatfull_4 <- treat[-treattest_4,]
treatfull_5 <- treat[-treattest_5,]
treatfull_6 <- treat[-treattest_6,]
treatfull_7 <- treat[-treattest_7,]
treatfull_8 <- treat[-treattest_8,]
treatfull_9 <- treat[-treattest_9,]
treatfull_10 <- treat[-treattest_10,]
Yfull_1<- ifelse(svdat[-c(0:107),]$approval<3, 1, 0)
Yfull_2<- ifelse(svdat[-c(108:215),]$approval<3, 1, 0)
Yfull_3<- ifelse(svdat[-c(216:323),]$approval<3, 1, 0)
Yfull_4<- ifelse(svdat[-c(324:431),]$approval<3, 1, 0)
Yfull_5<- ifelse(svdat[-c(432:539),]$approval<3, 1, 0)
Yfull_6<- ifelse(svdat[-c(540:647),]$approval<3, 1, 0)
Yfull_7<- ifelse(svdat[-c(648:755),]$approval<3, 1, 0)
Yfull_8<- ifelse(svdat[-c(756:863),]$approval<3, 1, 0)
Yfull_9<- ifelse(svdat[-c(864:971),]$approval<3, 1, 0)
Yfull_10<- ifelse(svdat[-c(972:1074),]$approval<3, 1, 0)
Xfull_1 <-model.matrix(~covsfull_1*treatfull_1)
xtest_1<- model.matrix(~covstest_1*treattest_1)
fit8<- bart(x.train=Xfull_1, y.train=factor(Yfull_1), x.test=xtest_1, ndpost=1000, nskip=500, usequants=T)
covsfull_1
treatfull_1
covs
treat
covstest_1 <- covs[c(0:107),]
covsfull_1 <- covs[-covstest_1,]
treattest_1 <- treat[c(0:107),]
treatfull_1 <-treat[-treattest_1,]
xtest_1<- model.matrix(~covstest_1*treattest_1)
fit8<- bart(x.train=Xfull_1, y.train=factor(Yfull_1), x.test=xtest_1, ndpost=1000, nskip=500, usequants=T)
=======
library(glmnet)
fit1<- cv.glmnet(y = Y, x= Xfull, alpha=1, family='binomial', type='mse')
fit1<- cv.glmnet(y = Y, x= Xfull, alpha=1, family='binomial', type='mse')
approve_bi <- y #line 432 of rep code
approve_bi<- ifelse(svdat$approval<3, 1, 0) #line 292 of rep code
approve_bi <- y #line 432 of rep code
approve_bi <- y #line 432 of rep code
FIY <- Y
Xfull <- model.matrix(~X*treat)
Xtfull <- model.matrix(~Xt*treatt) #line 56 of SLF
rm(list=ls(all=TRUE))
dem<- ifelse(svdat$pid3l=='Dem', 1, 0)  #line 366-369 of rep code
>>>>>>> 3cf8894b74faea8fbfc8d733624d28dbf3c22762
getwd()
setwd("/Users/emilygarner/Documents/School/Second Sem/R/Project")
load("Het_Experiment.Rdata")
dem<- ifelse(svdat$pid3l=='Dem', 1, 0)  #line 366-369 of rep code
dem[which(is.na(dem))]<- 0
rep<- ifelse(svdat$pid3l=='Rep', 1, 0)
rep[which(is.na(rep))]<- 0
cons<- ifelse(svdat$ideo3<3, 1, 0) #line 230-231 of rep code
lib<- ifelse(svdat$ideo3==4|svdat$ideo3==5, 1, 0)
lib[which(is.na(lib))]<- 0 #line 370-371 of rep code
cons[which(is.na(cons))]<- 0
type.mat<- matrix(0, nrow = 1074, ncol=7)
colnames(type.mat)<- sort(unique(as.character(svdat$cond.type)))
for(z in 1:nrow(type.mat)){
type.mat[z,which(colnames(type.mat)==svdat$cond.type[z])]<- 1
}
type.mat.final<- type.mat[,-1]
types<- sort(unique(as.character(svdat$cond.type)))
type.num<- match(svdat$cond.type, types)
number<- c('control', '$20 million', '$50 thousand')
amount.num<- match(svdat$cond.money, number)
request<- c('control', 'requested', 'secured', 'will request')
stage.num<- match(svdat$cond.stage, request)
party<- c('control', 'a Republican', 'a Democrat')
party.num<- match(svdat$cond.party, party)
along<- c('control', 'alone', 'w/ Rep', 'w/ Dem')
along.num<- match(svdat$cond.alongWith, along)
num.mat<- matrix(0, nrow=1074, ncol=3)
colnames(num.mat)<- number
for(z in 1:nrow(num.mat)){
num.mat[z,which(colnames(num.mat)==svdat$cond.money[z])]<- 1
}
num.mat.final<- num.mat[,-1]
stage.mat<- matrix(0, nrow=1074, ncol=4)
colnames(stage.mat)<- request
for(z in 1:nrow(stage.mat)){
stage.mat[z,which(colnames(stage.mat)==svdat$cond.stage[z])]<- 1
}
stage.mat.final<- stage.mat[,-1]
party.mat<- matrix(0, nrow=1074, ncol=3)
colnames(party.mat)<- party
for(z in 1:nrow(party.mat)){
party.mat[z, which(colnames(party.mat)==svdat$cond.party[z])]<- 1
}
party.mat.final<- party.mat[,-1]
along.mat<- matrix(0, nrow=1074, ncol=4)
colnames(along.mat)<- 	along
for(z in 1:nrow(along.mat)){
along.mat[z,which(colnames(along.mat)==svdat$cond.alongWith[z])]<- 1
}
along.mat.final<- along.mat[,-1]
treats<- cbind(type.mat.final, num.mat.final[,1], stage.mat.final[,1:2],party.mat.final[,1],
along.mat.final[,1:2], type.mat.final[,1:5]*num.mat.final[,1], type.mat.final[,1:5]*stage.mat.final[,1],
type.mat.final[,1:5]*stage.mat.final[,2], type.mat.final[,1:5]*party.mat.final[,1], type.mat.final[,1:5]*along.mat.final[,1],
type.mat.final[,1:5]*along.mat.final[,2], num.mat.final[,1]*stage.mat.final[,1], num.mat.final[,1]*stage.mat.final[,2],
num.mat.final[,1]*party.mat.final[,1], num.mat.final[,1]*along.mat.final[,1], num.mat.final[,1]*along.mat.final[,2],
stage.mat.final[,1:2]*party.mat.final[,1], stage.mat.final[,1:2]*along.mat.final[,1],
stage.mat.final[,1:2]*along.mat.final[,2], party.mat.final[,1]*along.mat.final[,1], party.mat.final[,1]*along.mat.final[,2] )
treat<- treats #line 448 of rep code
covs<- cbind(dem, rep, lib, cons) #line 373 of rep code
X <- covs #line 432 of repcode
Xfull <- model.matrix(~X*treat)
Y<- approve_bi<- ifelse(svdat$approval<3, 1, 0) #line 292 of rep code
Xfull <- model.matrix(~covs*treat)
Xfull_1 <-model.matrix(~covsfull_1*treatfull_1)
xtest<- model.matrix(~covstest_1*treattest_1)
fit8<- bart(x.train=Xfull, y.train=factor(Y), x.test=Xtfull, ndpost=1000, nskip=500, usequants=T)
fit8<- bart(x.train=Xfull_1, y.train=factor(Yfull_1), x.test=xtest_1, ndpost=1000, nskip=500, usequants=T)
covstest_1 <- covs[c(1:107),]
covstest_2<- covs[c(108:215),]
covstest_3<- covs[c(216:323),]
covstest_4<- covs[c(324:431),]
covstest_5<- covs[c(432:539),]
covstest_6<- covs[c(540:647),]
covstest_7<- covs[c(648:755),]
covstest_8<- covs[c(756:863),]
covstest_9<- covs[c(864:971),]
covstest_10<- covs[c(972:1074),]
covsfull_1 <- covs[-covstest_1,]
covsfull_2 <- covs[-covstest_2,]
covsfull_3 <- covs[-covstest_3,]
covsfull_4 <- covs[-covstest_4,]
covsfull_5 <- covs[-covstest_5,]
covsfull_6 <- covs[-covstest_6,]
covsfull_7 <- covs[-covstest_7,]
covsfull_8 <- covs[-covstest_8,]
covsfull_9 <- covs[-covstest_9,]
covsfull_10 <- covs[-covstest_10,]
covstest<- cbind(covsfull_1,covsfull_2,covsfull_3,covsfull_4,covsfull_5,covsfull_6,covsfull_7,covsfull_8,covsfull_9,covsfull_10)
covsfull<-cbind(covsfull_1,covsfull_2,covsfull_3,covsfull_4,covsfull_5,covsfull_6,covsfull_7,covsfull_8,covsfull_9,covsfull_10)
treattest_1 <- treat[c(1:107),]
treattest_2<- treat[c(108:215),]
treattest_3<- treat[c(216:323),]
treattest_4<-treat[c(324:431),]
treattest_5<- treat[c(432:539),]
treattest_6<- treat[c(540:647),]
treattest_7<- treat[c(648:755),]
treattest_8<- treat[c(756:863),]
treattest_9<- treat[c(864:971),]
treattest_10<- treat[c(972:1074),]
treattest<- cbind(treattest_2,treattest_3,treattest_4,treattest_5,treattest_6,treattest_7,treattest_8,treattest_9)
treatfull_1 <-treat[-treattest_1,]
treatfull_2 <- treat[-treattest_2,]
treatfull_3 <- treat[-treattest_3,]
treatfull_4 <- treat[-treattest_4,]
treatfull_5 <- treat[-treattest_5,]
treatfull_6 <- treat[-treattest_6,]
treatfull_7 <- treat[-treattest_7,]
treatfull_8 <- treat[-treattest_8,]
treatfull_9 <- treat[-treattest_9,]
treatfull_10 <- treat[-treattest_10,]
treatfull <-
#################
#def y in partions
Yfull_1<- ifelse(svdat[-c(1:107),]$approval<3, 1, 0)
Yfull_2<- ifelse(svdat[-c(108:215),]$approval<3, 1, 0)
Yfull_3<- ifelse(svdat[-c(216:323),]$approval<3, 1, 0)
Yfull_4<- ifelse(svdat[-c(324:431),]$approval<3, 1, 0)
Yfull_5<- ifelse(svdat[-c(432:539),]$approval<3, 1, 0)
Yfull_6<- ifelse(svdat[-c(540:647),]$approval<3, 1, 0)
Yfull_7<- ifelse(svdat[-c(648:755),]$approval<3, 1, 0)
Yfull_8<- ifelse(svdat[-c(756:863),]$approval<3, 1, 0)
Yfull_9<- ifelse(svdat[-c(864:971),]$approval<3, 1, 0)
Yfull_10<- ifelse(svdat[-c(972:1074),]$approval<3, 1, 0)
Yfull <-cbind(Yfull_1,Yfull_2,Yfull_3,Yfull_4,Yfull_5,Yfull_6,Yfull_7,Yfull_8,Yfull_9, Yfull_10)
first<- svdat[c(1:107),]
second<- svdat[c(108:215),]
third<- svdat[c(216:323),]
fourth<- svdat[c(324:431),]
fifth<- svdat[c(432:539),]
sixth<- svdat[c(540:647),]
seventh<- svdat[c(648:755),]
eighth<- svdat[c(756:863),]
ninth<- svdat[c(864:971),]
tenth<- svdat[c(972:1074),]
library(glmnet)
fit1<- cv.glmnet(y = Y, x= Xfull, alpha=1, family='binomial', type='mse')
<<<<<<< HEAD
?glmnet()
library(BayesTree)
library(BayesTree)
install.packages("BayesTree")
library(BayesTree)
fit8<- bart(x.train=Xfull, y.train=factor(Y), x.test=Xtfull, ndpost=1000, nskip=500, usequants=T)
Xtfull <- model.matrix(~Xt*treatt) #line 56 of SLF
Xt<- covs #line 432 of rep code
Xt<- covs #line 432 of rep code
treatt<- treats #line 432 of rep code
Xtfull <- model.matrix(~Xt*treatt) #line 56 of SLF
fit8<- bart(x.train=Xfull, y.train=factor(Y), x.test=Xtfull, ndpost=1000, nskip=500, usequants=T)
covstest_1 <- covs[c(1:107),]
covsfull_1 <- covs[-covstest_1,]
Xfull_1 <-model.matrix(~covsfull_1*treatfull_1)
fit8<- bart(x.train=Xfull, y.train=factor(Y), x.test=Xfull, ndpost=1000, nskip=500, usequants=T)
xtest<- model.matrix(~covstest_1*treattest_1)
Y<- approve_bi<- ifelse(svdat$approval<3, 1, 0) #line 292 of rep code
Yfull_1<- ifelse(svdat[-c(1:107),]$approval<3, 1, 0)
xtest_1 <- model.matrix(~covstest_1*treattest_1)
Xtest_1 <- model.matrix(~covstest_1*treattest_1)
Yfull_1<- ifelse(svdat[-c(1:107),]$approval<3, 1, 0)
fit8<- bart(x.train=Xfull_1, y.train=factor(Yfull_1), x.test=Xtest_1, ndpost=1000, nskip=500, usequants=T)
Xfull_1
nrow(Xfull_1)
?factor
factor
nrow(Xfull)
nrow(Y)
Y
View(covsfull_1)
covsfull_1 <- covs[,-covstest_1]
View(covsfull_1)
covsfull_1 <- covs[,-(covstest_1)]
View(covsfull_1)
View(covsfull_10)
View(covsfull_1)
View(covsfull_10)
View(covsfull_1)
covsfull_1 <- covs[-(covstest_1),]
View(covsfull_1)
covsfull_1 <- covs[-(covstest_1)]
covsfull_1 <- covs[-(covstest_1),]
covsfull_1 <- covs[-c(covstest_1),]
covstest_1 <- covs[c(1:107),]
covsfull_1 <- covs[-c(covstest_1),]
View(covsfull_1)
covsfull_1 <- covs[-c(1:107),]
covstest_1 <- covs[c(1:107),]
covsfull_1 <- covs[-c(1:107),]
treattest_1 <- treat[c(1:107),]
treatfull_1 <-treat[-c(1:107),]
Xfull_1 <-model.matrix(~covsfull_1*treatfull_1)
Xtest_1 <- model.matrix(~covstest_1*treattest_1)
Yfull_1<- ifelse(svdat[-c(1:107),]$approval<3, 1, 0)
fit8<- bart(x.train=Xfull_1, y.train=factor(Yfull_1), x.test=Xtest_1, ndpost=1000, nskip=500, usequants=T)
covstest_1 <- covs[c(1:107),]
covstest_2<- covs[c(108:215),]
covstest_3<- covs[c(216:323),]
covstest_4<- covs[c(324:431),]
covstest_5<- covs[c(432:539),]
covstest_6<- covs[c(540:647),]
covstest_7<- covs[c(648:755),]
covstest_8<- covs[c(756:863),]
covstest_9<- covs[c(864:971),]
covstest_10<- covs[c(972:1074),]
covstest<- cbind(covsfull_1,covsfull_2,covsfull_3,covsfull_4,covsfull_5,covsfull_6,covsfull_7,covsfull_8,covsfull_9,covsfull_10)
# Def of 9/10 for covs
covsfull_1 <- covs[-(1:107),]
covsfull_2 <- covs[-c(108:215),]
covsfull_3 <- covs[-c(216:323),]
covsfull_4 <- covs[-c(324:431),]
covsfull_5 <- covs[-c(432:539),]
covsfull_6 <- covs[-c(540:647),]
covsfull_7 <- covs[-c(648:755),]
covsfull_8 <- covs[-c(756:863),]
covsfull_9 <- covs[-c(864:971),]
covsfull_10 <- covs[-c(972:1074),]
covsfull<-cbind(covsfull_1,covsfull_2,covsfull_3,covsfull_4,covsfull_5,covsfull_6,covsfull_7,covsfull_8,covsfull_9,covsfull_10)
####def of 1/10 for treat
treattest_1 <- treat[c(1:107),]
treattest_2<- treat[c(108:215),]
treattest_3<- treat[c(216:323),]
treattest_4<-treat[c(324:431),]
treattest_5<- treat[c(432:539),]
treattest_6<- treat[c(540:647),]
treattest_7<- treat[c(648:755),]
treattest_8<- treat[c(756:863),]
treattest_9<- treat[c(864:971),]
treattest_10<- treat[c(972:1074),]
treattest<- cbind(treattest_2,treattest_3,treattest_4,treattest_5,treattest_6,treattest_7,treattest_8,treattest_9)
# Def of 9/10 for treat
treatfull_1 <-treat[-c(1:107),]
treatfull_2 <- treat[-c(108:215),]
treatfull_3 <- treat[-c(216:323),]
treatfull_4 <- treat[-c(324:431),]
treatfull_5 <- treat[-c(432:539),]
treatfull_6 <- treat[-c(540:647),]
treatfull_7 <- treat[-c(648:755),]
treatfull_8 <- treat[-c(756:863),]
treatfull_9 <- treat[-c(864:971),]
treatfull_10 <- treat[-c(972:1074),]
treatfull <-
#################
#def y in portions
Yfull_1<- ifelse(svdat[-c(1:107),]$approval<3, 1, 0)
Yfull_2<- ifelse(svdat[-c(108:215),]$approval<3, 1, 0)
Yfull_3<- ifelse(svdat[-c(216:323),]$approval<3, 1, 0)
Yfull_4<- ifelse(svdat[-c(324:431),]$approval<3, 1, 0)
Yfull_5<- ifelse(svdat[-c(432:539),]$approval<3, 1, 0)
Yfull_6<- ifelse(svdat[-c(540:647),]$approval<3, 1, 0)
Yfull_7<- ifelse(svdat[-c(648:755),]$approval<3, 1, 0)
Yfull_8<- ifelse(svdat[-c(756:863),]$approval<3, 1, 0)
Yfull_9<- ifelse(svdat[-c(864:971),]$approval<3, 1, 0)
Yfull_10<- ifelse(svdat[-c(972:1074),]$approval<3, 1, 0)
Yfull <-cbind(Yfull_1,Yfull_2,Yfull_3,Yfull_4,Yfull_5,Yfull_6,Yfull_7,Yfull_8,Yfull_9, Yfull_10)
#####
first<- svdat[c(1:107),]
second<- svdat[c(108:215),]
third<- svdat[c(216:323),]
fourth<- svdat[c(324:431),]
fifth<- svdat[c(432:539),]
sixth<- svdat[c(540:647),]
seventh<- svdat[c(648:755),]
eighth<- svdat[c(756:863),]
ninth<- svdat[c(864:971),]
tenth<- svdat[c(972:1074),]
?glmnet
?cv.glmnet
?bart
?glmnet
=======
install.packages("glmnet")
fit2<- cv.glmnet(y = Y, x= Xfull, alpha=0.5, family='binomial', type='mse')
fit3<- cv.glmnet(y = Y, x= Xfull, alpha=0.15, family='binomial', type='mse')
fit4<- cv.glmnet(y = Y, x= Xfull, alpha=0, family='binomial', type='mse')
library(KRLS)
fit11<- krls(X = Xfull[,-1], y = Y, derivative=F)
library(KRLS)
fit11<- krls(X = Xfull[,-1], y = Y, derivative=F)
fit5 <- FindIt(FIY,X.c=Xstd, treat2, type='multiple',
scale.c= SDsToRescaleX,
search.lambdas=TRUE,
fit.glmnet=TRUE,wts=1) }
install.packages("arm")
library(arm)
fit6<- bayesglm(Y~Xfull-1, family=binomial(link=logit))
install.packages("mboost")
install.packages("GAMBoost")
library(mboost)
library(GAMBoost)
fit7<- GLMBoost(Xfull[,-1],Y,penalty= 100,stepno=100,  trace = T,  family=binomial())
install.packages("mboost")
install.packages("mboost")
library(mboost)
library(GAMBoost)
fit7<- GLMBoost(Xfull[,-1],Y,penalty= 100,stepno=100,  trace = T,  family=binomial())
>>>>>>> bf7998bd49f5b12b9a6b3cbe6c67a57a4f70aeca
>>>>>>> 3cf8894b74faea8fbfc8d733624d28dbf3c22762
